const axios = require('axios');
const http = require('http');
const https = require('https');
const cheerio = require('cheerio');
const fs = require('fs').promises;
const { wrapper } = require('axios-cookiejar-support');
const { CookieJar } = require('tough-cookie');
const { Pool } = require('pg');
const path = require('path');
require('dotenv').config();
const mysql = require('mysql2/promise');


const MYSQL_HOST = '127.0.0.1' 
const MYSQL_PORT = 3306 
const MYSQL_USER = 'root'
const MYSQL_PASSWORD = 'root'
const MYSQL_DATABASE = 'testdb'

const agentOptions = {
  keepAlive: false
};

const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

const BASE_URL = 'https://www.offshorecorptalk.com';
const LOGIN_URL = `${BASE_URL}/login/login`;

const BACKUP_CODE = '636882647'; // Used if 2FA is required
const USERNAME = 'maxwellgeorgy60@gmail.com';
const PASSWORD = 'xOQ3Q3NcDm9MmKK';
const TWO_STEP_URL = `${BASE_URL}/login/two-step`;

const jar = new CookieJar();
const client = wrapper(axios.create({
  jar,
  withCredentials: true,
  headers: { 
    'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36'
  }
}));

let mysqlPool;

// PostgreSQL connection pool
const pgPool = new Pool({
  host: process.env.PG_HOST,
  port: process.env.PG_PORT,
  user: process.env.PG_USER,
  password: process.env.PG_PASSWORD,
  database: process.env.PG_DATABASE,
});

async function initMySQL() {
  mysqlPool = await mysql.createPool({
    host: MYSQL_HOST,
    port: MYSQL_PORT,
    user: MYSQL_USER,
    password: MYSQL_PASSWORD,
    database: MYSQL_DATABASE,
    waitForConnections: true,
    connectionLimit: 20, // Increased for better performance
    queueLimit: 0
  });
}

async function batchInsert(tableName, columns, values, batchSize = 1000) {
  if (values.length === 0) return;
  
  const columnList = columns.join(', ');
  const placeholders = `(${columns.map(() => '?').join(', ')})`;
  
  for (let i = 0; i < values.length; i += batchSize) {
    const batch = values.slice(i, i + batchSize);
    const batchPlaceholders = batch.map(() => placeholders).join(', ');
    const flatValues = batch.flat();
    
    try {
      await mysqlPool.query(
        `INSERT INTO ${tableName} (${columnList}) VALUES ${batchPlaceholders}`,
        flatValues
      );
      console.log(`Batch inserted ${batch.length} records into ${tableName}`);
    } catch (err) {
      console.log(`Failed to batch insert into ${tableName}: ${err.message}`);
    }
  }
}

function getNumberFromString(str) {
  if (!str) return 0;
  const cleaned = str.replace(/,/g, '');      // Remove commas
  const number = parseFloat(cleaned);         // Convert to number
  return isNaN(number) ? 0 : number;
}

// Helper: escape value for SQL
function sqlEscape(val) {
  if (val === null || val === undefined) return 'NULL';
  if (typeof val === 'number') return val;
  if (typeof val === 'boolean') return val ? 'TRUE' : 'FALSE';
  return `'${String(val).replace(/'/g, "''")}'`;
}

// Helper: escape value for MySQL/MariaDB
function sqlEscapeMariaDB(val) {
  if (val === null || val === undefined) return 'NULL';
  if (typeof val === 'number') return val;
  if (typeof val === 'boolean') return val ? 1 : 0;
  // MySQL uses \' for single quote in strings
  return `'${String(val).replace(/\\/g, "\\\\").replace(/'/g, "\\'")}'`;
}

// Helper: batch insert for MySQL/MariaDB (write to .dump file)
// Helper: batch insert for Postgres (write to .sql dump)
async function batchInsertPg(tableName, columns, values, stream, batchSize = 500) {
  if (values.length === 0) return;
  for (let i = 0; i < values.length; i += batchSize) {
    const batch = values.slice(i, i + batchSize);
    const valueStrings = batch.map(row => `(${row.map(sqlEscape).join(', ')})`);
    const sql = `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES\n  ${valueStrings.join(',\n  ')};\n`;
    await stream.write(sql);
  }
}

async function batchInsertMariaDB(tableName, columns, values, stream, batchSize = 500) {
  if (values.length === 0) return;
  for (let i = 0; i < values.length; i += batchSize) {
    const batch = values.slice(i, i + batchSize);
    const valueStrings = batch.map(row => `(${row.map(sqlEscapeMariaDB).join(', ')})`);
    const dump = `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES\n  ${valueStrings.join(',\n  ')};\n`;
    await stream.write(dump);
  }
}

// Save all scraped data to MariaDB/MySQL dump file
async function saveToMariaDB(forums, threads, posts, users) {
  const dumpPath = path.join(__dirname, 'xenforo_gold_dump.dump');
  const stream = await fs.open(dumpPath, 'w');
  const file = stream.createWriteStream();

  // Write header
  await file.write('-- MariaDB/MySQL compatible SQL dump generated by xenforo-gold-scraper.js\n');
  await file.write('SET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS=0;\n\n');

  // USERS
  const userColumns = ['username', 'user_id', 'user_title'];
  const userValues = users.map(u => [u.username, u.user_id, u.user_title]);
  await batchInsertMariaDB('xf_user', userColumns, userValues, file);

  // FORUMS
  const forumColumns = ['forum_id', 'title', 'description', 'meta', 'threads', 'messages'];
  const forumValues = forums.map(f => [f.forumId, f.title, f.description, f.meta, f.stats.threads, f.stats.messages]);
  await batchInsertMariaDB('xf_forum', forumColumns, forumValues, file);

  // THREADS
  const threadColumns = ['thread_id', 'forum_id', 'title', 'start_user_name', 'start_user_id', 'start_date', 'replies', 'views', 'last_post_date', 'last_post_user'];
  const threadValues = threads.map(t => [t.thread_id, t.forumId, t.title, t.start_user_name, t.start_user_id, t.start_date, t.replies, t.views, t.last_post_date, t.last_post_user]);
  await batchInsertMariaDB('xf_thread', threadColumns, threadValues, file);

  // POSTS
  const postColumns = ['post_id', 'thread_id', 'username', 'user_id', 'user_title', 'datetime', 'message_content', 'last_edited'];
  const postValues = posts.map(p => [p.post_id, p.thread_id, p.username, p.user_id, p.user_title, p.datetime, p.message_content, p.last_edited]);
  await batchInsertMariaDB('xf_post', postColumns, postValues, file);

  await new Promise(resolve => file.end(resolve));
  await stream.close();
  console.log('✅ MariaDB/MySQL SQL dump saved to xenforo_gold_dump.dump');
}

// Save all scraped data to PostgreSQL dump file
async function saveToPostgres(forums, threads, posts, users) {
  const dumpPath = path.join(__dirname, 'xenforo_gold_dump.sql');
  const stream = await fs.open(dumpPath, 'w');
  const file = stream.createWriteStream();

  // USERS
  const userColumns = ['username', 'user_id', 'user_title'];
  const userValues = users.map(u => [u.username, u.user_id, u.user_title]);
  await batchInsertPg('xf_user', userColumns, userValues, file);

  // FORUMS
  const forumColumns = ['forum_id', 'title', 'description', 'url', 'meta', 'threads', 'messages', 'latest_title', 'latest_date', 'latest_date_timestamp', 'latest_user'];
  const forumValues = forums.map(f => [f.forumId, f.title, f.description, f.url, f.meta, f.stats.threads, f.stats.messages, f.latest.summary, f.latest.date, f.latest.timestamp, f.latest.user]);
  await batchInsertPg('xf_forum', forumColumns, forumValues, file);

  // THREADS
  const threadColumns = ['thread_id', 'forum_id', 'title', 'start_user_name', 'start_user_id', 'start_date', 'replies', 'views', 'last_post_date', 'last_post_user'];
  const threadValues = threads.map(t => [t.thread_id, t.forumId, t.title, t.start_user_name, t.start_user_id, t.start_date, t.replies, t.views, t.last_post_date, t.last_post_user]);
  await batchInsertPg('xf_thread', threadColumns, threadValues, file);

  // POSTS
  const postColumns = ['post_id', 'thread_id', 'username', 'user_id', 'user_title', 'datetime', 'message_content', 'last_edited'];
  const postValues = posts.map(p => [p.post_id, p.thread_id, p.username, p.user_id, p.user_title, p.datetime, p.message_content, p.last_edited]);
  await batchInsertPg('xf_post', postColumns, postValues, file);

  await new Promise(resolve => file.end(resolve));
  await stream.close();
  console.log('✅ SQL dump saved to xenforo_gold_dump.sql');
}

async function login() {
  try {
    console.log('🔐 Logging in...');
    // Step 1: Get login page to fetch CSRF token
    const loginPage = await client.get(LOGIN_URL, {
      headers: {     
        'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36' 
      }
    });

    const $ = cheerio.load(loginPage.data);
    const csrfToken = $('input[name="_xfToken"]').val();
    if (!csrfToken) throw new Error('CSRF token not found');

    // Step 2: Submit login form
    const loginPayload = new URLSearchParams({
      login: USERNAME,
      password: PASSWORD,
      remember: '1',
      _xfToken: csrfToken,
      _xfRedirect: 'https://www.offshorecorptalk.com/'
    });

    const loginResponse = await client.post(LOGIN_URL, loginPayload, {
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
       'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
        Referer: LOGIN_URL
      },
      maxRedirects: 0,
      validateStatus: status => status === 200 || status === 302 || status === 303
    });
    console.log("loginResponse: ", loginResponse.status)
     // STEP 3: Check if 2FA page was returned
     let nextPage;
     if (loginResponse.status === 200) {
       // Still on a page, possibly asking for 2FA
       nextPage = loginResponse.data;
     } else if (loginResponse.status === 302 || loginResponse.status === 303) {
       // Check if we were redirected to 2FA page
       const redirectLocation = loginResponse.headers.location;
       console.log('redirectLocation: ', redirectLocation)
       if (redirectLocation && redirectLocation.includes('/two-step')) {
         const twoStepPage = await client.get(
          'https://www.offshorecorptalk.com/login/two-step?provider=backup&remember=1&_xfRedirect=https%3A%2F%2Fwww.offshorecorptalk.com%2F',
          {
            headers: {
              Referer: LOGIN_URL
            }
         }); //(`${redirectLocation}$${'provider=backup'}`);
         console.log('twpStepPage: ', `${redirectLocation}$${'provider=backup'}`)
         nextPage = twoStepPage.data;
       } else {
         nextPage = await client.get(HOME_URL).then(r => r.data);
       }
     }
     const $$ = cheerio.load(nextPage || '');
     const is2FARequired = $$('form[action$="/login/two-step"]').length > 0;
     console.log('is2FARequired: ', is2FARequired)
     if (is2FARequired) {
      const twoFactorToken = $$('input[name="_xfToken"]').val();
      const provider = $$('input[name="provider"]').val();
      console.log('twoFactorToken: ', twoFactorToken)
      console.log('provider: ', provider)
      if (!twoFactorToken || !provider) throw new Error('❌ 2FA form incomplete');

      console.log('🔐 Submitting backup code for 2FA...');

      const twoStepPayload = new URLSearchParams({
        provider: 'backup',
        code: BACKUP_CODE,
        trust: '1',
        remember: '1',
        confirm: '1',
        _xfToken: twoFactorToken,
        _xfResponseType: 'json',
        _xfWithData: '1',
        _xfRedirect: 'https://www.offshorecorptalk.com/',
        _xfRequestUri: 'https://www.offshorecorptalk.com/login/two-step?provider=backup&remember=1&_xfRedirect=https%3A%2F%2Fwww.offshorecorptalk.com%2F'
      });

      const twoStepResponse = await client.post(`${BASE_URL}/login/two-step`, twoStepPayload, {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Origin': BASE_URL,
          'Referer': `${BASE_URL}/login/two-step`,
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'
        },
        maxRedirects: 0,
        validateStatus: status => [200, 302, 303].includes(status)
      });
      console.log('twoStepResponse: ', twoStepResponse.status)
      if ([200, 302, 303].includes(twoStepResponse.status)) {
        console.log('✅ 2FA code accepted, redirected');
        // console.log('data: ', twoStepResponse.data)
      } else {
        console.log('❌ 2FA failed');
      }
    }

    // STEP 4: Confirm login by checking homepage
    const homepage = await client.get(BASE_URL);
    const $$$ = cheerio.load(homepage.data);
    const usernameText = $$$('.p-navgroup-link--user').text().trim();
    if (usernameText) {
      console.log(`✅ Logged in successfully as: ${usernameText}`);
    } else {
      console.log('❌ Login appeared successful, but user not detected');
    }
  } catch (err) {
    console.error('[-] Error:', err.message);
  }
}

async function getAllForumLinks() {
  const res = await client.get(BASE_URL);
  const $ = cheerio.load(res.data);
  const links = [];

  $('div.node--forum h3 a').each((_, el) => {
    const href = $(el).attr('href');
    const name = $(el).text().trim();
    if (href) {
      links.push({
        name,
        url: BASE_URL + href,
        path: href
      });
    }
  });

  return links;
}

async function getThreadsFromPage(url) {
  const $ = await fetchHtml(url);
  const threads = [];

  $('div.structItem--thread').each((_, el) => {
    const a = $(el).find('.structItem-title a');
    const href = a.attr('href');
    if (href) {
      threads.push({
        title: a.text().trim(),
        url: BASE_URL + href,
      });
    }
  });

  return threads;
}

async function getPostsFromThread(url) {
  const $ = await fetchHtml(url);
  const posts = [];

  $('article.message').each((_, el) => {
    const user = $(el).find('.message-name').text().trim();
    const content = $(el).find('.message-content').text().trim();
    posts.push({ user, content });
  });

  return posts;
}

async function fetchHtml(url) {
  // await sleep(1000); // wait 1 second between requests
  const res = await client.get(url);
  return cheerio.load(res.data);
}

async function delay(ms) {
  return new Promise(res => setTimeout(res, ms));
}

async function getLastPageNumber(categoryUrl) {
  const $ = await fetchHtml(categoryUrl);
  let lastPage = 1;

  $('ul.pageNav-main li').each((_, el) => {
    const num = parseInt($(el).text().trim(), 10);
    if (!isNaN(num) && num > lastPage) {
      lastPage = num;
    }
  });

  return lastPage;
}

async function scrapeForumNodes() {
  const $ = await fetchHtml(BASE_URL);
  const results = [];

  $('div.node--forum').each((_, el) => {
    const node = $(el);

    const title = node.find('.node-title a').text().trim();
    const url = BASE_URL + node.find('.node-title a').attr('href');
    const forumId = extractForumId(url)
    const description = node.find('.node-description').text().trim();
    const meta = node.find('.node-meta').text().trim();

    // const statsText = node.find('.node-stats').text().trim();
    // const threadsMatch = statsText.match(/Threads:\s*([\d,]+)/i);
    // const messagesMatch = statsText.match(/Messages:\s*([\d,]+)/i);
    // const threads = threadsMatch ? threadsMatch[1] : null;
    // const messages = messagesMatch ? messagesMatch[1] : null;
    const threads = node.find('.node-stats .pairs.pairs--rows dd').first().text().trim();
    const messages = node.find('.node-stats .pairs.pairs--rows dd').last().text().trim();

    const latestTitle = node.find('.node-extra-row a').text().trim();
    const latestDate = node.find('time.node-extra-date').attr('datetime') || '';
    const latestDateTimestamp = node.find('time.node-extra-date').attr('data-timestamp') || '';
    const latestUser = node.find('.node-extra-user').text().trim();
    // const extraRow = node.find('.node-extra-row').text().trim();
    // const extraDate = node.find('time.node-extra-date').attr('datetime') || '';
    // const extraUser = node.find('.node-extra-user').text().trim();

    results.push({
      title,
      url,
      forumId,
      description,
      meta,
      stats: {
        threads,
        messages
      },
      latest: {
        summary: latestTitle,
        date: latestDate,
        timestamp: latestDateTimestamp,
        user: latestUser
      }
    });
  });

  return results;
}

async function scrapSubForums(url) {
  try {
    const $ = await fetchHtml(url);
    const sub_forums = [];
  
    $('.block-body .node').each((_, el) => {
      const $node = $(el);
      const titleEl = $node.find('.node-title a');
      const description = $node.find('.node-description').text().trim();
      const threads = $node.find('.node-stats dl:contains("Threads") dd').text().trim();
      const messages = $node.find('.node-stats dl:contains("Messages") dd').text().trim();
      const lastThread = $node.find('.node-extra-title');
      const lastThreadTitle = lastThread.text().trim();
      const lastThreadUrl = BASE_URL + lastThread.attr('href');
      const lastUser = $node.find('.node-extra-user a').text().trim();
      const lastUserProfile = BASE_URL + $node.find('.node-extra-user a').attr('href');
      const lastActivityDate = $node.find('.node-extra-date').attr('title');
      const lastActivityTimestamp = $node.find('.node-extra-date').attr('data-timestamp');
      sub_forums.push({
        title: titleEl.text().trim(),
        url: BASE_URL + titleEl.attr('href'),
        forumId: extractForumId(BASE_URL + titleEl.attr('href')),
        description,
        threads,
        messages,
        lastThreadTitle,
        lastThreadUrl,
        lastUser,
        lastUserProfile,
        lastActivityDate,
        lastActivityTimestamp
      });
    });
    return sub_forums
  } catch (error) {
    console.log('error: ', error)
  }
}

async function scrapeForum() {
  await login();
  await initMySQL();
  const [threads] = await mysqlPool.query(
    `SELECT * FROM threads`
  );
  const existingIds = new Set(threads.map(row => row.thread_id));
  console.log('existingIds:', existingIds)
  const [forums] = await mysqlPool.query(
    `SELECT * FROM forums`
  );
  // const forums = await getAllForumLinks();
  // console.log('nodeDetails: ', nodeDetails)
  // console.log('forums: ', forums)
  // const forums = await scrapeForumNodes();
  // console.log('forums: ', forums)
  const allThreads = [];
  const allPosts = [];
  const allUsers = new Map();
  const output = [];
  // console.log('length: ', forums.length)
  for (const forum of forums) {
    console.log(`📂 Scraping forum: ${forum.title}`);
    const forumIds = [10, 13, 15, 18, 19, 20, 22, 24, 27, 28, 49, 56, 69, 72, 79]
    if (forumIds.includes(forum.forum_id)) {
      continue;
    }
    console.log('forum: ', forum)
    const categoryUrl = forum.url//`${forum.url}` //`${BASE_URL}${forum.url}`
    const lastPage = await getLastPageNumber(categoryUrl);
    await InsertForumData(forum, lastPage)
    for (let page = 1; page <= lastPage; page++) {
      const pageUrl = `${categoryUrl}page-${page}` //`${BASE_URL}${forum.path}page-${page}`;
      console.log('pageUrl: ', pageUrl)
      const threads = await scrapeThreadsFromForum(forum.forum_id, pageUrl)
      let i = 0;
      for (const thread of threads) {
        if (!existingIds.has(parseInt(thread.thread_id))) {
          await InsertThreadData(thread, page)
        }
        const lastThreadPage = await getLastPageNumber(thread.thread_url);
        console.log('lastThreadPage: ', lastThreadPage)
        console.log('index ==>', i)
        i++;
        for (let page = 1; page <= lastThreadPage; page++) {
          const threadPageUrl = `${thread.thread_url}page-${page}`
          const thread_post = await scrapePostsFromThread(threadPageUrl)
          for (const post of thread_post.posts) {
            // console.log('post => ', post)
            // const user_profile = await scrapeUserProfile(post.user_href)
            // console.log('user profile: ', post.user_href, user_profile)
            allPosts.push({ ...post, thread_id: thread.thread_id });
            if (post.username) allUsers.set(post.username, { username: post.username, user_id: post.user_id, user_title: post.user_title });
          }
          const posts = await scrapeThreadsFromForum(thread.url)
          // console.log('posts: ', posts)
          output.push({ forum: forum.title, title: thread.title, url: thread.url, posts });
          // Collect thread info
          allThreads.push({ ...thread, forumId: forum.forumId });
          await delay(500);
        }
      // }
      }
      await delay(500);
    }
  }

  await fs.writeFile('xenforo_gold_dump.json', JSON.stringify({
    forums,
    threads: allThreads,
    posts: allPosts
  }, null, 2), 'utf-8');
  // Save to PostgreSQL
  await saveToPostgres(forums, allThreads, allPosts, Array.from(allUsers.values()));
  await saveToMariaDB(forums, allThreads, allPosts, Array.from(allUsers.values()));
  await fs.writeFile('xenforo_gold_dump.json', JSON.stringify({ forums, threads: allThreads, posts: allPosts, users: Array.from(allUsers.values()) }, null, 2), 'utf-8');
  console.log('✅ Dump saved to xenforo_gold_dump.json');
}

async function scrapePosts() {
  await login();
  await initMySQL();
  const forumIds = [11, 26, 31, 32,47, 48, 51, 55, 57, 58, 60, 63, 68, 70, 71, 75, 77, 86, 92, 93, 96]
  const placeholders = forumIds.map(() => '?').join(', ');
  const [threads] = await mysqlPool.query(
    `SELECT * FROM threads WHERE forum_id IN (${placeholders}) ORDER BY thread_id DESC`,
    forumIds
  );
  const existingIds = new Set(threads.map(row => row.thread_id));
  console.log('existingIds:', existingIds)
  const allThreads = [];
  const allPosts = [];
  const allUsers = new Map();
  const output = [];
  for (const thread of threads) {
    const lastThreadPage = await getLastPageNumber(thread.thread_url);
    console.log('lastThreadPage: ', lastThreadPage, thread.thread_id)
    for (let page = 1; page <= lastThreadPage; page++) {
      const threadPageUrl = `${thread.thread_url}page-${page}` //`${BASE_URL}${forum.path}page-${page}`;
      console.log('threadPageUrl: ', threadPageUrl)
      const thread_post = await scrapePostsFromThread(threadPageUrl)
      let i = 0;
      for (const post of thread_post.posts) {
        // console.log('post => ', post)
        await InsertPostData(thread.thread_id, post, page)
        console.log('index ==>', i)
        i++;
        // const user_profile = await scrapeUserProfile(post.user_href)
        // console.log('user profile: ', post.user_href, user_profile)
        // allPosts.push({ ...post, thread_id: thread.thread_id });
        // if (post.username) allUsers.set(post.username, { username: post.username, user_id: post.user_id, user_title: post.user_title });
      }
      // const posts = await getPostsFromThread(thread.url);
      // const posts = await scrapeThreadsFromForum(thread.url)
      // console.log('posts: ', posts)
      // output.push({ forum: forum.title, title: thread.title, url: thread.url, posts });
      // Collect thread info
      // allThreads.push({ ...thread, forumId: forum.forumId });
      await delay(500);
    }
  }
  console.log('✅ Dump saved to xenforo_gold_dump.json');
}

async function batchScrapPosts() {
  await login();
  await initMySQL();
  const forumIds = [11, 26, 31, 32,47, 48, 51, 55, 57, 58, 60, 63, 68, 70, 71, 75, 77, 86, 92, 93, 96]
  const placeholders = forumIds.map(() => '?').join(', ');
  const [threads] = await mysqlPool.query(
    `SELECT * FROM threads WHERE forum_id IN (${placeholders}) ORDER BY thread_id ASC`,
    forumIds
  );
  const threadIds = threads.map(row => row.thread_id)
  const placeholders2 = threadIds.map(() => '?').join(', ');
  const [replies] = await mysqlPool.query(
    `SELECT * FROM posts WHERE thread_id IN (${placeholders2}) ORDER BY post_id DESC`,
    threadIds
  );
  const existingIds = new Set(threads.map(row => row.thread_id));
  const existingThreadIds = new Set(replies.map(row => row.thread_id));
  console.log('existingThreadIds:', existingThreadIds.size, existingIds.size)
  for (const thread of threads) {
    // if (thread.thread_id < 9706) {
    //   continue;
    // }
    if (existingThreadIds.has(thread.thread_id)) {
      continue;
    }
    console.log('thread id: ', thread.thread_id)
    const lastThreadPage = await getLastPageNumber(thread.thread_url);
    console.log('lastThreadPage: ', lastThreadPage, thread.thread_id)
    for (let page = 1; page <= lastThreadPage; page++) {
      const threadPageUrl = `${thread.thread_url}page-${page}` //`${BASE_URL}${forum.path}page-${page}`;
      console.log('threadPageUrl: ', threadPageUrl)
      const thread_post = await scrapePostsFromThread(threadPageUrl)
      console.log('posts length: ', thread_post.posts.length)
      const columns = [
        'post_id',
        'thread_id',
        'message_id',
        'username',
        'user_id',
        'user_href',
        'user_title',
        'post_url',
        'datetime',
        'datetimestamp',
        'readable_time',
        'message_content',
        'last_edited',
        'last_edited_timestamp',
        'thread_page_number',
        'points',
        'reaction_score',
        'joined',
        'messages',
        'age',
        'location'
      ];
      const values = thread_post.posts.map(post => [
        post.post_id,
        thread.thread_id,
        post.message_id,
        post.username,
        post.user_id,
        post.user_href,
        post.user_title,
        post.post_url,
        new Date(post.datetime),
        post.datetimestamp,
        post.readable_time,
        post.message_content,
        new Date(post.last_edited),
        post.last_edited_timestamp,
        page,
        getNumberFromString(post.extra.points),
        getNumberFromString(post.extra.reaction_score),
        post.extra.joined,
        getNumberFromString(post.extra.messages),
        getNumberFromString(post.extra.age),
        post.extra.location
      ]);
      await batchInsert('posts', columns, values)
      await delay(500);
    }
  }
  console.log('✅ Dump saved to xenforo_gold_dump.json');
}

const fixDate = (dateStr) => {
  const date = new Date(dateStr);
  return isNaN(date) ? null : date.toISOString().slice(0, 19).replace('T', ' ');
};

async function batchScrapUsers() {
  await login();
  await initMySQL();
  const [replies] = await mysqlPool.query(
    `SELECT * FROM posts ORDER BY post_id ASC`
  );
  const [users] = await mysqlPool.query(
    `SELECT * FROM users ORDER BY id ASC`
  );
  const existingUserIds = new Set(users.map(row => row.id));
  const existingUserNames = new Set(users.map(row => row.username));
  const addedUsers = new Set()
  for (const reply of replies) {
    try {
      if (reply.post_id < 300000) {
        continue;
      }
      if (existingUserIds.has(reply.user_id)) {
        continue;
      }
      if (addedUsers.has(reply.user_id)) {
        continue;
      }
      const userPageUrl = `${reply.user_href}`;
      console.log('userPageUrl: ', userPageUrl)
      if (userPageUrl.includes('undefined')) {
        continue;
      }
      const user_info = await scrapeUserProfile(userPageUrl)
      const columns = [
        'id',
        'username',
        'title',
        'link',
        'created_at',
        'updated_at',
        'joined_at',
        'last_seen',
        'location',
        'gender',
        'occupation',
        'messages',
        'reaction_score',
        'points',
        'featured_content',
        'avatar'
      ];
      console.log('userInfo: ', user_info)
      const values = [
        user_info.userId,
        reply.username,
        user_info.userTitle,
        reply.user_href,
        fixDate(new Date(user_info.registerDate)),
        fixDate(new Date(user_info.lastSeen)),
        fixDate(new Date(user_info.registerDate)),
        fixDate(new Date(user_info.lastSeen)),
        user_info.location,
        user_info.gender,
        user_info.occupation,
        user_info.stats.messages,
        getNumberFromString(user_info.stats.reactions),
        user_info.stats.points,
        user_info.stats.featured_content,
        user_info.avatarUrl
      ];
      try {
        const columnList = columns.join(', ');
        const placeholders = `(${columns.map(() => '?').join(', ')})`;
        await mysqlPool.query(
          `INSERT INTO users (${columnList}) VALUES ${placeholders}`,
          values
        );
        console.log(`Batch inserted 1 record into users`);
      } catch (err) {
        console.log(`Failed to batch insert into users: ${err.message}`);
      }
      addedUsers.add(reply.user_id)
      // await batchInsert('users', columns, values)
      await delay(500);
    } catch (error) {
      console.log('reply error: ', error)
    }
  }
  console.log('✅ Dump saved to xenforo_gold_dump.json');
}

async function batchScrap() {
  await login();
  const url = 'https://www.offshorecorptalk.com/members/drifter-gse.9801/'
  const userId = 9801
  const username = 'Drifter GSEDrifter GSE'
  try {
    const user_info = await scrapeUserProfile(url)
    console.log('userInfo: ', user_info)
    const columns = [
      'id',
      'username',
      'title',
      'link',
      'created_at',
      'updated_at',
      'joined_at',
      'last_seen',
      'location',
      'gender',
      'occupation',
      'messages',
      'reaction_score',
      'points',
      'featured_content',
      'avatar'
    ];
    const values = [
      userId,
      username,
      user_info.userTitle,
      url,
      fixDate(new Date(user_info.registerDate)),
      fixDate(new Date(user_info.lastSeen)),
      fixDate(new Date(user_info.registerDate)),
      fixDate(new Date(user_info.lastSeen)),
      user_info.location,
      user_info.gender,
      user_info.occupation,
      user_info.stats.messages,
      getNumberFromString(user_info.stats.reactions),
      user_info.stats.points,
      user_info.stats.featured_content,
      user_info.avatarUrl
    ];
    console.log('values : ', columns, values)
    await delay(500);
  } catch (error) {
    console.log('reply error: ', error)
  }
  console.log('✅ Dump saved to xenforo_gold_dump.json');
}

function extractForumId(url) {
  const match = url.match(/\.([0-9]+)\/?$/);
  return match ? match[1] : null;
}

function extractThreadId(threadUrl) {
  const match = threadUrl.match(/\.([0-9]+)\//);
  return match ? match[1] : null;
}

function extractPostId(url) {
  const match = url.match(/post-(\d+)/);
  return match ? match[1] : null;
}

async function scrapeThreadsFromForum(forum_id, FULL_URL) {
  const $ = await fetchHtml(FULL_URL);
  const threads = [];

  $('div.structItem--thread').each((_, el) => {
    const item = $(el);

    const dataUserId = item.attr('data-user-id') || null;
    const threadStatus = item.find('.structItem-status').attr('class') || '';
    // const threadHref = item.find('.structItem-title').attr('hix-href')//titleEl.attr('href'); // e.g. "/threads/some-thread.12345/"
    const titleLink = item.find('.structItem-title a[href]').last(); // Last <a> is usually the thread link
    const threadHref = titleLink.attr('href') || '';
    const title = titleLink.text().trim();
    // const threadUrl = threadHref.startsWith('/')
    // const threadHref = item.find('.structItem-title').attr('hix-href')
    const threadUrl = threadHref ? BASE_URL + threadHref : null;
    const threadId = extractThreadId(threadUrl)
    const labelOrange = item.find('.structItem-title .label').text().trim() || null;
    const usernameEl = item.find('.structItem-minor a.username');
    const startUsername = usernameEl.text().trim();
    
    // Example href: "/members/goldseeker.12345/"
    const userProfileHref = usernameEl.attr('href') || '';
    const userIdMatch = userProfileHref.match(/\.([0-9]+)\//);
    const startUserId = userIdMatch ? userIdMatch[1] : null;
    const threadStartDate = item.find('time.u-dt').attr('datetime') || null;
    const threadStartDateTimestamp = item.find('time.u-dt').attr('data-timestamp') || null;
    const preview = item.find('.structItem-snippet').text().trim() || null;
    const metaCells = item.find('.structItem-cell--meta dd');
    const replies = metaCells.eq(0).text().trim();
    const views = metaCells.eq(1).text().trim();

    const lastPostDate = item.find('time.structItem-latestDate').attr('datetime') || null;
    const lastPostDateTimestamp = item.find('time.structItem-latestDate').attr('data-timestamp') || null;

    const username = item.find('.structItem-minor .username').text().trim();
    const lastPostUser = item.find('.structItem-minor .username').attr('data-user-id');
    // const lastPostUser = item.find('.structItem-latestDate').siblings('a.username').text().trim() || null;
    const avatarImg = item.find('.structItem-iconContainer img').attr('src') || null;
    const userProfileUrl = BASE_URL + (item.find('.structItem-iconContainer a').attr('href') || '');

    threads.push({
      data_user_id: dataUserId,
      structItem_status: threadStatus,
      title,
      label: labelOrange,
      preview,
      thread_url: threadUrl,
      thread_id: threadId,
      forum_id,
      start_user_name: startUsername,
      start_user_id: startUserId,
      start_date: threadStartDate,
      start_date_timestamp: threadStartDateTimestamp,
      replies,
      views,
      last_post_date: lastPostDate,
      last_post_date_timestamp: lastPostDateTimestamp,
      last_post_user: lastPostUser,
      thread_posted_by: username,
      user_avatar: avatarImg,
      user_profile_url: userProfileUrl
    });
  });

  return threads;
}

function extractUserIdFromProfileUrl(profileUrl) {
  const match = profileUrl?.match(/\.([0-9]+)\//);
  return match ? match[1] : null;
}

async function scrapePostsFromThread(url) {
  const $ = await fetchHtml(url);

  // Thread header
  const threadTitle = $('h1.p-title-value').text().trim();
  const label = $('h1.p-title-value .label').text().trim();
  const pDescription = $('.p-description').text().trim();

  const posts = [];

  $('.message--post').each((_, el) => {
    const post = $(el);
    const messageId = post.attr('data-content') || null;

    const usernameEl = post.find('.message-name .username');
    const username = usernameEl.text().trim();
    const userHref = usernameEl.attr('href');
    const userId = extractUserIdFromProfileUrl(userHref);

    const userTitle = post.find('.message-userTitle').text().trim();
    const userExtras = {}
    $('.message-userExtras dl').each((_, el) => {
      const label = $(el).find('dt span').attr('title');
      const value = $(el).find('dd').text().trim();
      if (label && value) {
        if (label == 'Joined') {
          userExtras['joined'] = value
        } else if (label == 'Points') {
          userExtras['points'] = value
        } else if (label == 'Reaction score') {
          userExtras['reaction_score'] = value
        } else if (label == 'Messages') {
          userExtras['messages'] = value
        } else if (label == 'Age') {
          userExtras['age'] = value
        } else if (label == 'Location') {
          userExtras['location'] = value
        }
      }
    });
    const post_url = post.find('li.u-concealed a').attr('href')
    const post_id = extractPostId(post_url)
    const datetime = post.find('time.u-dt').attr('datetime') || null;
    const datetimestamp = post.find('time.u-dt').attr('data-timestamp') || null;
    const readableTime = post.find('time.u-dt').text().trim();

    const messageContent = post.find('.message-content .bbWrapper').html()?.trim() || '';

    const lastEdit = post.find('.message-lastEdit .u-dt').attr('datetime') || null;
    const lastEditTimestamp = post.find('.message-lastEdit .u-dt').attr('data-timestamp') || null;
    posts.push({
      message_id: messageId,
      username,
      user_id: userId,
      user_href: `${BASE_URL}${userHref}`,
      user_title: userTitle,
      post_url,
      post_id,
      datetime,
      datetimestamp,
      readable_time: readableTime,
      message_content: messageContent,
      last_edited: lastEdit,
      last_edited_timestamp: lastEditTimestamp,
      extra: {
        points: userExtras['points'],
        reaction_score: userExtras['reaction_score'],
        joined: userExtras['joined'],
        messages: userExtras['messages'],
        age: userExtras['age'],
        location: userExtras['location']
      }
    });
  });

  const threadData = {
    thread_url: url,
    p_title: threadTitle,
    label,
    p_description: pDescription,
    posts
  };

  return threadData
}

async function scrapeUserProfile(url) {
  const $ = await fetchHtml(`${url}#about`);
  const username = $('.username').text().trim();
  const userTitle = $('.userTitle').text().trim();
  const userId = $('.username').attr('data-user-id')
  // const username = $('h1.p-title-value').text().trim();
  // const userIdMatch = url.match(/\.([0-9]+)\/?$/);
  // const userId = userIdMatch ? userIdMatch[1] : null;
  const avatarUrl = $('.avatar img').attr('src')?.startsWith('/')
    ? BASE_URL + $('.avatar img').attr('src')
    : $('.avatar img').attr('src');

  // const userTitle = $('.userBanner').text().trim() || null;

  // Robust extraction for 'last seen' and 'joined' (register date)
  let lastSeen = null;
  let registerDate = null;
  $('.pairs.pairs--inline').each((_, el) => {
    $(el).find('dt').each((i, dtEl) => {
      const dt = $(dtEl).text().trim().toLowerCase();
      const dd = $(dtEl).next('dd').text().trim();
      if (dt.includes('last seen')) lastSeen = dd;
      if (dt.includes('joined')) registerDate = dd;
    });
  });
  // Extract stats
  const stats = {};
  $('.pairs.pairs--rows').each((_, el) => {
    const dt = $(el).find('dt').text().trim().toLowerCase();
    const dd = $(el).find('dd').text().trim();
    if (dt.includes('messages')) stats.messages = dd;
    else if (dt.includes('reaction score')) stats.reactions = dd;
    else if (dt.includes('points')) stats.points = dd;
  });

  const location = $('dt:contains("Location")').next('dd').text().trim();
  const occupation = $('dl[data-field="occupation"] dd').text().trim();
  const gender = $('dl[data-field="gender"] dd').text().trim();
  $('dl.pairs').each((_, el) => {
    const key = $(el).find('dt').text().trim().toLowerCase().replace(/\s+/g, '_');
    const valText = $(el).find('dd').text().replace(/,/g, '').trim();
    const value = isNaN(valText) ? valText : parseInt(valText, 10);
    stats[key] = value;
  });
  return {
    username,
    userId,
    userTitle,
    avatarUrl,
    registerDate,
    lastSeen,
    location,
    occupation,
    gender,
    stats: {
      messages: stats.messages,
      reactions: stats.reactions,
      points: stats.points,
      featured_content: stats.featured_content,
    }
  };
}

async function InsertSubForumData(forum) {
  console.log('forum: ', forum)
  const columns = [
    'forum_id',
    'title',
    'url',
    'description',
    'threads',
    'messages',
    'latest_summary',
    'latest_date',
    'latest_timestamp',
    'latest_user',
    'last_thread_url',
    'threads_page_count'
  ];
  const flatValues =  [
    forum.forumId,
    forum.title,
    forum.url,
    forum.description,
    getNumberFromString(forum.threads),
    getNumberFromString(forum.messages),
    forum.lastThreadTitle,
    new Date(forum.lastActivityDate),
    forum.lastActivityTimestamp,
    forum.lastUser,
    forum.lastThreadUrl,
    1
  ];
  const columnList = columns.join(', ');
  const placeholders = `(${columns.map(() => '?').join(', ')})`;
  try {
    await mysqlPool.query(
      `INSERT INTO forums (${columnList}) VALUES ${placeholders}`,
      flatValues
    );
    console.log(`Batch inserted ${columnList.length} records into forums`);
  } catch (error) {
    console.log('error', error)
  }
}

async function InsertForumData(forum, page_number) {
  console.log('forum: ', forum)
  const columns = [
    'forum_id',
    'title',
    'url',
    'description',
    'threads',
    'messages',
    'latest_summary',
    'latest_date',
    'latest_timestamp',
    'latest_user',
    'threads_page_count'
  ];
  const flatValues =  [
    forum.forumId,
    forum.title,
    forum.url,
    forum.description,
    getNumberFromString(forum.stats.threads),
    getNumberFromString(forum.stats.messages),
    forum.latest.summary,
    new Date(forum.latest.date),
    forum.latest.timestamp,
    forum.latest.user,
    page_number
  ];
  const columnList = columns.join(', ');
  const placeholders = `(${columns.map(() => '?').join(', ')})`;
  try {
    await mysqlPool.query(
      `INSERT INTO forums (${columnList}) VALUES ${placeholders}`,
      flatValues
    );
    console.log(`Batch inserted ${columnList.length} records into forums`);
  } catch (error) {
    console.log('error', error)
  }
}

async function InsertThreadData(thread, page_number) {
  try {
    console.log('thread: ', thread.thread_id)
    const columns = [
      'thread_id',
      'forum_id',
      'title',
      'label',
      'thread_url',
      'start_user_name',
      'start_user_id',
      'start_date',
      'start_date_timestamp',
      'replies',
      'views',
      'last_post_date',
      'last_post_date_timestamp',
      'last_post_user',
      'thread_posted_by',
      'user_avatar',
      'user_profile_url',
      'forum_page_number',
    ];
    const flatValues =  [
      thread.thread_id,
      thread.forum_id,
      thread.title,
      thread.label,
      thread.thread_url,
      thread.start_user_name,
      thread.start_user_id,
      new Date(thread.start_date),
      thread.start_date_timestamp,
      getNumberFromString(thread.replies),
      getNumberFromString(thread.views),
      new Date(thread.last_post_date),
      thread.last_post_date_timestamp,
      thread.last_post_user,
      thread.thread_posted_by,
      thread.user_avatar,
      thread.user_profile_url,
      page_number
    ];
    const columnList = columns.join(', ');
    const placeholders = `(${columns.map(() => '?').join(', ')})`;
    try {
      await mysqlPool.query(
        `INSERT INTO threads (${columnList}) VALUES ${placeholders}`,
        flatValues
      );
      console.log(`Batch inserted ${columnList.length} records into threads`);
    } catch (error) {
      console.log('error', error)
    }
  } catch (error) {
    console.log('error', error)
  }
}

async function InsertPostData(thread_id, post, page_number) {
  console.log('post: ', post.post_id)
  const columns = [
    'post_id',
    'thread_id',
    'message_id',
    'username',
    'user_id',
    'user_href',
    'user_title',
    'post_url',
    'datetime',
    'datetimestamp',
    'readable_time',
    'message_content',
    'last_edited',
    'last_edited_timestamp',
    'thread_page_number',
    'points',
    'reaction_score',
    'joined',
    'messages',
    'age',
    'location'
  ];
  const flatValues =  [
    post.post_id,
    thread_id,
    post.message_id,
    post.username,
    post.user_id,
    post.user_href,
    post.user_title,
    post.post_url,
    new Date(post.datetime),
    post.datetimestamp,
    post.readable_time,
    post.message_content,
    new Date(post.last_edited),
    post.last_edited_timestamp,
    page_number,
    post.getNumberFromString(extra.points),
    post.getNumberFromString(extra.reaction_score),
    post.extra.joined,
    post.getNumberFromString(extra.messages),
    post.extra.age,
    post.extra.location
  ];
  const columnList = columns.join(', ');
  const placeholders = `(${columns.map(() => '?').join(', ')})`;
  try {
    await mysqlPool.query(
      `INSERT INTO posts (${columnList}) VALUES ${placeholders}`,
      flatValues
    );
    console.log(`Batch inserted ${columnList.length} records into posts`);
  } catch (error) {
    console.log('error', error)
  }
}

batchScrapPosts().catch(console.error);
